/*!

DEC	OCT	HEX	BIN	Symbol	HTML Number	HTML Name	Description
32 040	20	00100000	SP	&#32;	 	Space
33 041	21	00100001	!	&#33;	&excl;	Exclamation mark
34 042	22	00100010	"	&#34;	&quot;	Double quotes (or speech marks)
35 043	23	00100011	#	&#35;	&num;	Number sign
36 044	24	00100100	$	&#36;	&dollar;	Dollar
37 045	25	00100101	%	&#37;	&percnt;	Per cent sign
38 046	26	00100110	&	&#38;	&amp;	Ampersand
39 047	27	00100111	'	&#39;	&apos;	Single quote
40 050	28	00101000	(	&#40;	&lparen;	Open parenthesis (or open bracket)
41 051	29	00101001	)	&#41;	&rparen;	Close parenthesis (or close bracket)
42 052	2A	00101010	*	&#42;	&ast;	Asterisk
43 053	2B	00101011	+	&#43;	&plus;	Plus
44 054	2C	00101100	,	&#44;	&comma;	Comma
45 055	2D	00101101	-	&#45;	 	Hyphen-minus
46 056	2E	00101110	.	&#46;	&period;	Period, dot or full stop
47 057	2F	00101111	/	&#47;	&sol;	Slash or divide
48 060	30	00110000	0	&#48;	 	Zero
49 061	31	00110001	1	&#49;	 	One
50 062	32	00110010	2	&#50;	 	Two
51 063	33	00110011	3	&#51;	 	Three
52 064	34	00110100	4	&#52;	 	Four
53 065	35	00110101	5	&#53;	 	Five
54 066	36	00110110	6	&#54;	 	Six
55 067	37	00110111	7	&#55;	 	Seven
56 070	38	00111000	8	&#56;	 	Eight
57 071	39	00111001	9	&#57;	 	Nine
58 072	3A	00111010	:	&#58;	&colon;	Colon
59 073	3B	00111011	;	&#59;	&semi;	Semicolon
60 074	3C	00111100	<	&#60;	&lt;	Less than (or open angled bracket)
61 075	3D	00111101	=	&#61;	&equals;	Equals
62 076	3E	00111110	>	&#62;	&gt;	Greater than (or close angled bracket)
63 077	3F	00111111	?	&#63;	&quest;	Question mark
64 100	40	01000000	@	&#64;	&commat;	At sign
65 101	41	01000001	A	&#65;	 	Uppercase A
66 102	42	01000010	B	&#66;	 	Uppercase B
67 103	43	01000011	C	&#67;	 	Uppercase C
68 104	44	01000100	D	&#68;	 	Uppercase D
69 105	45	01000101	E	&#69;	 	Uppercase E
70 106	46	01000110	F	&#70;	 	Uppercase F
71 107	47	01000111	G	&#71;	 	Uppercase G
72 110	48	01001000	H	&#72;	 	Uppercase H
73 111	49	01001001	I	&#73;	 	Uppercase I
74 112	4A	01001010	J	&#74;	 	Uppercase J
75 113	4B	01001011	K	&#75;	 	Uppercase K
76 114	4C	01001100	L	&#76;	 	Uppercase L
77 115	4D	01001101	M	&#77;	 	Uppercase M
78 116	4E	01001110	N	&#78;	 	Uppercase N
79 117	4F	01001111	O	&#79;	 	Uppercase O
80 120	50	01010000	P	&#80;	 	Uppercase P
81 121	51	01010001	Q	&#81;	 	Uppercase Q
82 122	52	01010010	R	&#82;	 	Uppercase R
83 123	53	01010011	S	&#83;	 	Uppercase S
84 124	54	01010100	T	&#84;	 	Uppercase T
85 125	55	01010101	U	&#85;	 	Uppercase U
86 126	56	01010110	V	&#86;	 	Uppercase V
87 127	57	01010111	W	&#87;	 	Uppercase W
88 130	58	01011000	X	&#88;	 	Uppercase X
89 131	59	01011001	Y	&#89;	 	Uppercase Y
90 132	5A	01011010	Z	&#90;	 	Uppercase Z
91 133	5B	01011011	`[`	&#91;	&lsqb;	Opening bracket
92 134	5C	01011100	\	&#92;	&bsol;	Backslash
93 135	5D	01011101	]	&#93;	&rsqb;	Closing bracket
94 136	5E	01011110	^	&#94;	&Hat;	Caret - circumflex
95 137	5F	01011111	_	&#95;	&lowbar;	Underscore
96 140	60	01100000	`	&#96;	&grave;	Grave accent
97 141	61	01100001	a	&#97;	 	Lowercase a
98 142	62	01100010	b	&#98;	 	Lowercase b
99 143	63	01100011	c	&#99;	 	Lowercase c
100 144	64	01100100	d	&#100;	 	Lowercase d
101 145	65	01100101	e	&#101;	 	Lowercase e
102 146	66	01100110	f	&#102;	 	Lowercase f
103 147	67	01100111	g	&#103;	 	Lowercase g
104 150	68	01101000	h	&#104;	 	Lowercase h
105 151	69	01101001	i	&#105;	 	Lowercase i
106 152	6A	01101010	j	&#106;	 	Lowercase j
107 153	6B	01101011	k	&#107;	 	Lowercase k
108 154	6C	01101100	l	&#108;	 	Lowercase l
109 155	6D	01101101	m	&#109;	 	Lowercase m
110 156	6E	01101110	n	&#110;	 	Lowercase n
111 157	6F	01101111	o	&#111;	 	Lowercase o
112 160	70	01110000	p	&#112;	 	Lowercase p
113 161	71	01110001	q	&#113;	 	Lowercase q
114 162	72	01110010	r	&#114;	 	Lowercase r
115 163	73	01110011	s	&#115;	 	Lowercase s
116 164	74	01110100	t	&#116;	 	Lowercase t
117 165	75	01110101	u	&#117;	 	Lowercase u
118 166	76	01110110	v	&#118;	 	Lowercase v
119 167	77	01110111	w	&#119;	 	Lowercase w
120 170	78	01111000	x	&#120;	 	Lowercase x
121 171	79	01111001	y	&#121;	 	Lowercase y
122 172	7A	01111010	z	&#122;	 	Lowercase z
123 173	7B	01111011	{	&#123;	&lcub;	Opening brace
124 174	7C	01111100	|	&#124;	&verbar;	Vertical bar
125 175	7D	01111101	}	&#125;	&rcub;	Closing brace
126 176	7E	01111110	~	&#126;	&tilde;	Equivalency sign - tilde
 */
use crate::expressions::encoding::MIN_CHAR;
use crate::expressions::numbers;
use crate::expressions::parser::{BinOp, IntType, NatType, UnOp, Var};
use miette::miette;
use std::cell::OnceCell;
use std::fmt::{Debug, Display, Formatter};

pub const ALIEN_ASCII : &'static str = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"#$%&'()*+,-./:;<=>?@[\\]^_`|~ \n";

pub trait Decode: Sized {
  fn decode(input: &str) -> miette::Result<Self>;
}

impl Decode for String {
  fn decode(input: &str) -> miette::Result<Self> {
    let result = input
      .chars()
      .map(|c| {
        let idx = c as usize - (MIN_CHAR as usize);
        ALIEN_ASCII.chars().nth(idx).unwrap()
      })
      .collect::<String>();

    Ok(result)
  }
}

impl Decode for IntType {
  fn decode(input: &str) -> miette::Result<Self> {
    Ok(numbers::base94_decode(input)?)
  }
}

impl Decode for Var {
  fn decode(input: &str) -> miette::Result<Self> {
    Ok(Var(
      NatType::try_from(&numbers::base94_decode(input)?).unwrap(),
    ))
  }
}

impl Decode for bool {
  fn decode(input: &str) -> miette::Result<Self> {
    match input {
      "T" => Ok(true),
      "F" => Ok(false),
      c => Err(miette!("Unknown bool: {c}")),
    }
  }
}

impl Decode for UnOp {
  fn decode(input: &str) -> miette::Result<Self> {
    let op = match input {
      "-" => UnOp::Negate,
      "!" => UnOp::Not,
      "#" => UnOp::StrToInt,
      "$" => UnOp::IntToStr,
      _ => return Err(miette!("Unknown unary operator: {input}")),
    };

    Ok(op)
  }
}

impl Decode for BinOp {
  fn decode(input: &str) -> miette::Result<BinOp> {
    let op = match input {
      "+" => BinOp::Add,
      "-" => BinOp::Sub,
      "*" => BinOp::Mul,
      "/" => BinOp::Div,
      "%" => BinOp::Mod,
      "<" => BinOp::LessThan,
      ">" => BinOp::GreaterThan,
      "=" => BinOp::Equals,
      "|" => BinOp::Or,
      "&" => BinOp::And,
      "." => BinOp::Concat,
      "T" => BinOp::TakeChars,
      "D" => BinOp::SkipChars,
      "$" => BinOp::ApplyLambda,
      _ => return Err(miette!("Unknown binary operator: {input}")),
    };

    Ok(op)
  }
}

pub enum DeferredDecode<T> {
  Deferred {
    coded: String,
    lazy: OnceCell<miette::Result<T>>,
  },
  Lit(T),
}

impl<T: Clone> DeferredDecode<T> {
  pub fn deferred(body: &str) -> Self {
    Self::Deferred {
      coded: body.to_string(),
      lazy: OnceCell::new(),
    }
  }
}

impl<T: Clone> Clone for DeferredDecode<T> {
  fn clone(&self) -> Self {
    match self {
      DeferredDecode::Deferred { coded, .. } => DeferredDecode::deferred(coded),
      DeferredDecode::Lit(i) => DeferredDecode::Lit(i.clone()),
    }
  }
}

impl PartialEq for DeferredDecode<IntType> {
  fn eq(
    &self,
    other: &Self,
  ) -> bool {
    match (self, other) {
      (DeferredDecode::Deferred { coded, .. }, DeferredDecode::Deferred { coded: right, .. }) => {
        coded == right
      }
      (DeferredDecode::Lit(left), DeferredDecode::Lit(right)) => left == right,
      (def @ DeferredDecode::Deferred { .. }, DeferredDecode::Lit(l))
      | (DeferredDecode::Lit(l), def @ DeferredDecode::Deferred { .. }) => {
        def.decode().unwrap() == l.clone()
      }
    }
  }
}

impl PartialEq for DeferredDecode<String> {
  fn eq(
    &self,
    other: &Self,
  ) -> bool {
    match (self, other) {
      (DeferredDecode::Deferred { coded, .. }, DeferredDecode::Deferred { coded: right, .. }) => {
        coded == right
      }
      (DeferredDecode::Lit(left), DeferredDecode::Lit(right)) => left == right,
      (def @ DeferredDecode::Deferred { .. }, DeferredDecode::Lit(l))
      | (DeferredDecode::Lit(l), def @ DeferredDecode::Deferred { .. }) => {
        def.decode().unwrap() == l
      }
    }
  }
}

impl Eq for DeferredDecode<String> {}
impl Eq for DeferredDecode<IntType> {}

impl DeferredDecode<IntType> {
  pub fn decode(&self) -> miette::Result<IntType> {
    match self {
      DeferredDecode::Deferred { coded, lazy } => {
        let res = lazy.get_or_init({
          let clone = coded.clone();
          move || numbers::base94_decode(&clone)
        });
        match res {
          Ok(i) => Ok(i.clone()),
          Err(e) => Err(miette!("Failed to decode: {e:?}")),
        }
      }
      DeferredDecode::Lit(lit) => Ok(lit.clone()),
    }
  }
}

impl DeferredDecode<String> {
  pub fn decode(&self) -> miette::Result<&str> {
    match self {
      DeferredDecode::Deferred { coded, lazy } => {
        let res = lazy.get_or_init({
          let clone = coded.clone();
          move || String::decode(&clone)
        });
        match res {
          Ok(s) => Ok(&s),
          Err(e) => Err(miette!("Failed to decode: {e:?}")),
        }
      }
      DeferredDecode::Lit(lit) => Ok(lit),
    }
  }
}

impl Debug for DeferredDecode<IntType> {
  fn fmt(
    &self,
    f: &mut Formatter<'_>,
  ) -> std::fmt::Result {
    f.debug_tuple("Int").field(&self.decode()).finish()
  }
}

impl Debug for DeferredDecode<String> {
  fn fmt(
    &self,
    f: &mut Formatter<'_>,
  ) -> std::fmt::Result {
    f.debug_tuple("String").field(&self.decode()).finish()
  }
}

impl Display for DeferredDecode<IntType> {
  fn fmt(
    &self,
    f: &mut Formatter<'_>,
  ) -> std::fmt::Result {
    match self.decode() {
      Ok(v) => write!(f, "{}", v),
      e => write!(f, "Int({:?})", e),
    }
  }
}

impl Display for DeferredDecode<String> {
  fn fmt(
    &self,
    f: &mut Formatter<'_>,
  ) -> std::fmt::Result {
    match self.decode() {
      Ok(v) => write!(f, "{:?}", v),
      e => write!(f, "String({:?})", e),
    }
  }
}

#[cfg(test)]
mod tests {
  use crate::expressions::decoding::Decode;
  use crate::expressions::parser::{BinOp, UnOp};

  #[test]
  fn decode_string() -> miette::Result<()> {
    let input = "B%,,/}Q/2,$_";
    let expected = "Hello World!";

    let result = String::decode(input)?;
    assert_eq!(result, expected);

    Ok(())
  }

  #[test]
  fn decode_unop() -> miette::Result<()> {
    let input = "-";
    let expected = UnOp::Negate;
    let result = UnOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "!";
    let expected = UnOp::Not;
    let result = UnOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "#";
    let expected = UnOp::StrToInt;
    let result = UnOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "$";
    let expected = UnOp::IntToStr;
    let result = UnOp::decode(input)?;
    assert_eq!(result, expected);

    Ok(())
  }

  #[test]
  fn decode_binop() -> miette::Result<()> {
    let input = "+";
    let expected = BinOp::Add;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "-";
    let expected = BinOp::Sub;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "*";
    let expected = BinOp::Mul;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "/";
    let expected = BinOp::Div;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "%";
    let expected = BinOp::Mod;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "<";
    let expected = BinOp::LessThan;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = ">";
    let expected = BinOp::GreaterThan;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "=";
    let expected = BinOp::Equals;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "|";
    let expected = BinOp::Or;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "&";
    let expected = BinOp::And;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = ".";
    let expected = BinOp::Concat;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "T";
    let expected = BinOp::TakeChars;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "D";
    let expected = BinOp::SkipChars;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    let input = "$";
    let expected = BinOp::ApplyLambda;
    let result = BinOp::decode(input)?;
    assert_eq!(result, expected);

    Ok(())
  }

  #[test]
  fn decode_bools() {
    assert_eq!(bool::decode("T").unwrap(), true);
    assert_eq!(bool::decode("F").unwrap(), false);
    assert!(bool::decode("D").is_err());
  }
}
